0. Introduction
---------------

This files shortly introduces the code structure of the v2cc code
generator. The code generator is responsible for creating C++ code from
the parsed VHDL node tree generated by vaul. 


1. Source files of v2cc
-----------------------

The source files v2cc (actually, the executable is named freehdl-v2cc)
is build from are:

- v2cc-util.cc and v2cc-util.h: these files define and implement
common functions within the code generator. E.g., they contain
functions to convert integers, doubles, longs to string and vice
versa. 

- v2cc-chunk.t: contains definitions of all v2cc specific methods and
slots added to the vaul/FIRE parser nodes.

- v2cc-const-fold.cc: contains generic methods to perform constant
folding on the nodes generated by vaul.

- v2cc-explore.cc: generic methods to analyze the node tree and to
collect various information from the VHDL model, e.g. which signals
are accessed or written by which processes. Further, these methods
perform all necessary and required error checking. I.e., if the model
passed this stage then all compile time detectable errors should have
been identified. Hence, no further checking is necessary by the
remaining methods.

- v2cc-decl.cc: generic methods to generate C++ code from the vaul
nodes. This methods are actually called after the node tree has been
constructed from the VHDL source. They call the other nodes in order
to generate all required C++ code.

- v2cc-acl.cc: generic methods to extract acl code from various
expressions.

- v2cc-get-type-info.cc: generic methods to emit type info code. Type
infos are used by the generated code to hold information about types
(e.g., left and right bound). They are especially use to store the
bounds of arrays.

- v2cc-qid.cc: generic methods to emit qualified identifier C++
names. All VHDL identifiers are finally mapped to corresponding C++
classes, objects, or functions. As the naming conventions and
visibility rules of VHDL and C++ differ all VHDL objects and
declarations get assigned an unique C++ name which does does not only
contain the identifier name but also the name of the declarative
region. E.g., a variable "var" declared in a process "proc" of an
architecture "arch" belonging to entity "ent" will be assigned the C++
name "L3ent_A4arch_P4proc_V3var".

- v2cc-expr.cc: generic methods to emit C++ code for expression nodes.

- v2cc-impl.cc: generic methods to output the implementation of the
C++ classes and functions while the definitions are created by methods
defined in v2cc-decl.cc.

- v2cc.cc: contains the main program and some auxiliary class and
function implementations.

- v2cc.h: defines a couple of commonly used data structures, constants
and instances.


2. v2cc execution
-----------------

When v2cc is executed it will first initialize various data structures
and then call vaul to parse the VHDL source file. The resulting node
tree is then passed over to the actual code generation routines.
The main generic code generation methods are called as follows:

- emit_decl: this is the main method which controls C++ code
generations. Under control of emit_decl the generic methods
explore_and_check, emit_hdr and emit_impl are executed in the
following order

	1. explore_and_check: it is responsible for error checking,
	constant folding and collection of information required by the
	code generation process. explore_and_checks mainly executes
	the following methods in order to perform its tasks:

		- explore_and_check (recursively)
		- get_context: collection information 
		- constant_fold: perform constant folding
		- check_expression: error check expressions

	Note that information collection, constant folding and
	expression checking are usually executed on all descendents of
	a node when a node is visited by explore_and_check. However,
	the actual processing strongly depends on the node type. See
	v2cc-explore.cc for more information on this.

	2.- emit_impl: if no errors were found then the actual code
	generation phase starts executing emit_impl. This will
	generate the implementation C++ code. I.e., code for class
	methods as well as normal functions are created. Note that
	these generic methods are executed BEFORE emit_hdr (which
	generates the corresponding class declarations and function
	prototypes) because during emit_impl some internal objects may
	be created which (of course) has also to be declared in
	emit_hdr. 

	3. emit_hdr: output the definitions of classes and functions
	generated from the VHDL source.


Please note that this list does not cover all generic methods which
are called during code generation. It should give only a short
overview how the code generation actually works. For more details
browse through the source code.

