
#ifndef DSYM_H
#define DSYM_H

/** \file

   Classes derived from sym and sym_scoped

   The name dsym is a play on calculus.  In calculus dx is a
   derivitive in terms of x.  dsym is a derivitive in terms of sym.

 */

/*===============================<o>=====================================

Copyright 1996, 1997, 2004 Ian Kaplan, Bear Products International,
www.bearcave.com.

All Rights Reserved

You may use this software in software components for which you do
not collect money (e.g., non-commercial software).  All commercial
use is reserved.

===============================<o>=====================================*/

#include "stdtypes.h"
#include "sym.h"
#include "type.h"
#include "const.h"
#include "symtable.h"
#include "typetable.h"

#ifndef NULL
#define NULL 0
#endif


/**
   Class to represent named constants and enumerations

   See const.h for a definition of the const and pConst
   types.

 */
class sym_const : public sym {
private:
    pConst konst;

public:
    sym_const(STRING n) : sym( n )
    { 
	konst = NULL; 
    }

    sym_const()
    {
	konst = NULL;
    }

    const uint get_sy_kind(void) { return sy_const; }

    void set_const( pConst c )
    {
	konst = c;
    }
    const pConst get_const(void)
    {
	return konst;
    }
}; // sym_const



/**
    Derived symbol class for named types.

    Base class for typed objects: identifiers, named constants, functions

    The type associated with the symbol is allocated separately.  This
    type is used to initialize the type field of this class.

 */
class sym_type : public sym {
private:
    pType ty;

public:
    sym_type(STRING n ) : sym( n )
    {
	ty = NULL;
    } // sym_type constructor

    sym_type()
    {
	ty = NULL;
    }

    const uint get_sy_kind(void) { return sy_type; }

    const pType get_ty_type(void) 
    { 
	return ty; 
    } // get_type
    void set_ty_type( pType t ) 
    { 
	assert( t != NULL );
	ty = t;
    } // set_type

}; // sym_type



enum { sy_bad_alloc,
       sy_static_id,
       sy_frame_id 
     };

enum { sy_bad_ident_type,
       sy_signal,
       sy_variable };

/**
   Class for variable identifiers.  Note that this does not include
   constants (they will be sym_const objects).

   The properties of identifiers are:
<ul>
<li>
<p>    
       allocation
</p>
<p>
       Is the identifier allocated staticly or in the frame.  Signals
       and variables declared in processes are allocated in static data.
       Variables in procedures and functions are frame allocated.
</p>
</li>
<li>
<p>
       Variable kind
</p>
<p>
       Is the identifier a signal or a variable.
</p>
</li>
</ul>
     Note that there is no variable offset associated with the symbol,
     since this is generated by the code generation phase.  Symbols in
     the p-code generated by the VHDL elaborator are referenced by name.
     This is also true for frame allocated variables.

     Each variable has a declaration in the p-code generated for a
     process.  For frame allocated variables this declaration must
     identify the variable as a frame variable.  The code generator
     can then build up the frame frame size and offsets within a
     frame.  This fully decouples p-code generation from any machine
     dependent code generation.
 */
class sym_ident : public sym_scoped {
private:
    pType ty;
    uint id_alloc : 3,    // sy_static_id, sy_frame_id, ...
         id_kind  : 3,    // sy_signal, sy_variable
	 unused   : 26; 
public:
    sym_ident(STRING n) : sym_scoped( n )
    {
	ty = NULL;
	id_alloc = sy_bad_alloc;
	id_kind = sy_bad_ident_type;
    }

    sym_ident()
    {
	ty = NULL;
	id_alloc = sy_bad_alloc;
	id_kind = sy_bad_ident_type;
    }

    const uint get_sy_kind(void) { return sy_ident; }
    
    void set_alloc( uint alloc )
    {
	id_alloc = alloc;
    } // set_offset
    const uint get_alloc(void)
    {
	return id_alloc;
    }

    void set_id_kind( uint kind )
    {
	id_kind = kind;
    }
    const uint get_id_kind(void)
    {
	return id_kind;
    }

    void set_id_type( pType t ) 
    { 
	assert( t != NULL );
	ty = t;
    } // set_type
    const pType get_id_type(void) 
    { 
	return ty; 
    } // get_type
}; // sym_ident



/**
   This class is used for a named item that has scope information (for
   example, a procedure or a function).  These objects also exist in a
   scope, so the object is derived from sym_scoped.  However, for some
   scope objects, like components (an elaborated entity architecture
   pair) there is no parent scope.

 */
class sym_scope : public sym_scoped {
private:
    sym *find_in_scope( sym *pSym, STRING sym_name );

private:
  /** Don't allow copying of sym_scope objects via copy constructor */
    sym_scope( const sym_scope &s )
    {
	assert( FALSE );
    }

protected:
    symtable symtab;
    typetable typtab;

public:
    //
    // constructors
    // 
    sym_scope(STRING n ) : sym_scoped( n )
    {
    }

    sym_scope()
    {
    }

    void dealloc(void)
    {
	symtab.dealloc();
	typtab.~typetable();
    }
    //upwards lookup starting from 'this' scope
    sym *LookupFromScope(STRING s);

    sym *LookupFromScope(const char *pChar )
    {
	STRING local_str;

	local_str.SetText( pChar );
	return LookupFromScope( local_str );
    }

    symtable *get_symtab(void)
    {
	return &symtab;
    }

    typetable *get_typtab(void)
    {
	return &typtab;
    }

  /** Return true when the symbol has associated scope (e.g., 
      a symbol table.
  */
    Boolean has_scope()
    {
	return TRUE;
    }
};  // sym_scope


/**
    This class represents VHDL procedures and functions.  This
    class is derived from sym_scope, so this is an object that
    contains local scope (e.g., a local symbol table).  If
    the type is NULL, its a procedure.

    Note that transformation turns functions into procedures.  After
    transformation, the function results becomes an argument (by
    convention, usually the first argument).

 */
class sym_subprog : public sym_scope {
private:
  pType ty;
  NODE *tree;

public:
  FIFO_LIST<sym_ident *> arg_list;

public:
    sym_subprog(STRING n ) : sym_scope( n )
    {
	tree = NULL;
	ty = NULL;
    }

    sym_subprog()
    {
	tree = NULL;
	ty = NULL;
    }

    const uint get_sy_kind(void) { return sy_subprog; }

    void set_statement( NODE *s )
    {
	tree = s;
    }
    const NODE *get_statement(void)
    {
	return tree;
    }

    void set_func_type( pType t )
    {
	ty = t;
    }

    const pType get_func_type(void)
    {
	return ty;
    }

};   // sym_subprog


/**
   In VHDL (as in Verilog), processes are strange things.  A process
   exists in its parent scope (a component or module) and it may have
   local variables and functions (e.g., it has a local symbol table).
   In this sense it is similar to a subprogram.  However, unlike a
   subprogram a process does not have to have a name (although it may
   have a name associated with it for readability).  So a process is
   not a symbol and can't be looked up in the symbol table.

   For simplicities sake the process class is an alias of the
   sym_scope class, which provides a symbol table and a parent scope
   pointer.

   A process is allocated via the local symbol table, but it is
   not entered in the symbol table.  This is done so that there
   is a uniform method for allocating all symbol derived objects.

 */
class sym_process : public sym_scope {
public:
    LIST<sym_ident *> active_list;  // process activation list

public:
    sym_process(STRING n ) : sym_scope( n )
    {
    }
    sym_process()
    {
    }

    const uint get_sy_kind(void) { return sy_process; }
};


/**
   A component is a bound entity architecture pair.  As 
   a result, components only exist after elaboration when
   this binding is defined.

   After p-code and "import" information is generated for
   a component the statement trees and VHDL symbol information
   can be discarded.  As a result, a component has its own
   associated memory pool, in addition to having its own symbol
   table (which it inherits from the sym_scope class).

   As with all symbols, the sym_component object is usually
   dynamically allocated.  Since the copy constructor is 
   not allowed for a pool, the class must be explicitly 
   initialized by calling init().

 */
class sym_component : public sym_scope {
private:
    pool mem;  // memory pool for this component

private:
    // No copy constructor allowed
    sym_component( const sym_component &c )
    {
	assert( FALSE );
    }

    void proc_list_dealloc(void);

private:
    LIST<sym *> proc_list;  // list of processes
    LIST<NODE *> sigass_list;       // list of signal assignments

public:
    sym_component( STRING n ) : sym_scope( n )
    {
	init();
    }
    sym_component()
    {
	init();
    }

    ~sym_component()
    {
	dealloc();
    }

    const uint get_sy_kind(void) { return sy_component; }

    void init(void)
    {
      /** get a new memory pool */
	mem.new_pool();   
	/** Set the memory allocation pools for the symbol and
	    type tables. */
	symtab.set_pool( &mem );
	typtab.set_pool( &mem );
	
    }
    void dealloc(void)
    {
      /** deallocate symbol and type table from base class */
        sym_scope::dealloc();  
	proc_list_dealloc();
	sigass_list.dealloc();
	/** release the memory pool */
	mem.delete_pool();  
    }


  /** Allocate memory from the pool that is local to the 
      component.
  */
    void *GetMem( uint num_bytes )
    {
	void *pMem;

	pMem = mem.GetMem( num_bytes );
	return pMem;
    }

    LIST<sym *> *get_proc_list(void)
    {
	return &proc_list;
    }
    LIST<NODE *> *get_sigass_list(void)
    {
	return &sigass_list;
    }
}; // sym_component


#endif
